---

title: 'Deep Learning - NLP 자연어처리 정리 1(벡터화, 전처리)'

categories: ['Data Science', 'Deep Learning']

tags: 
- 딥러닝

use_math: true

toc: true
toc_label: "My Table of Contents"
toc_icon: "cog"

---


# 자연어:
사람들이 일상적으로 쓰는 언어이다. 인공언어가 아닌 언어를 뜻하며, 인공언어로는 코딩 언어나 기계어 등이 있다. 일반적인 자연어를 단위 별로 구분할 때는 아래와 같이 쪼개어 볼 수 있다.

**말뭉치(Corpus):** 특정한 목적을 가지고 수집한 자연어 데이터. 수많은 단어와 문장, 문서로 이뤄진 text 데이터 그 자체.

**문서(Documents):** 문장들의 집합

**문장(Sentences):** 여러 개의 토큰(단어)들로 이뤄진 문자열, 특수문자, 마침표 등

**토큰(token):** 문서 내의 text(단어)를 숫자로 표현하기 위해 토큰화(Tokenize)하였을 때의 해당 text(단어)에 해당하는 숫자

**어휘집단(Vocabulary):** Corpus에 있는 모든 문서, 문장을 토큰화한 것으로 토큰(단어)의 중복을 제거한 뒤의 집합.

## 자연어 처리 모델과 벡터화
**벡터화:** 컴퓨터는 Text를 인식할 수 없으므로 숫자로 변경해주어야 한다. 문자를 숫자로 변경하여 우리가 원하는 내용을 예측하거나 번역, 생성할 수 있도록 하려면 단순이 숫자로 바꾸는 것이 아니라 어떠한 로직이 필요할 것이다. 아래는 그러한 방법론들을 구축하는 model 알고리즘 별로 나누어 적어본다.


### 1. 통계적 언어모델(Statistical Language Model):
통계적 언어모델은 조건부 확률의 방법으로 '이 단어 다음에 다음 단어가 올 확률'을 계산해서 이를 예측하는 모델이다. 자세한 내용은 다시 다루도록 할 것이며, 이에 따른 벡터화 방법을 우선 알아본다.

아래의 두 가지 방법은 문서 내에서 나오는 **빈도에 따라 구분하게 되는 표현 방법**이다.
* 단어의 순서를 신경쓰지 않는다.
* 단어의 의미, 문맥 등이 고려되지 않는다.


#### Bag Of Words(BOW):
가장 대표적인 통계적 언어모델에서의 벡터화 방법이다. 가방 안에 단어를 넣는다는 의미로 문장이 들어가더라도 단어들의 순서가 중요치 않으며, 문서 내에서 문장의 단어가 나온 횟수(빈도)만큼 중요도를 나타낸다고 보는 개념이다.

ex) I am a student, I am smart의 3개 문장의 요소를 쪼개서 보면 아래와 같이 나타낼 수 있다.

||I|am|a|student|smart|
|:-:|:-:|:-:|:-:|:-:|:-:|
I am a student|1|1|1|1|0|
I am smart|1|1|0|0|1|
TOTAL|2|2|1|1|1|

위와 같이 등장 횟수 별로 중요도를 파악하는 방법을 빈도 기반의 벡터화 중 Bag Of Word라 한다.

#### TF IDF (Term Frequency Inverse Document Frequency)
이름에서 말하는 Term은 단어를 의미한다. TF는 문장이 주어졌을 때 단어의 빈도를 일컫는 말이며, IDF는 문장들의 총 합에 따른 가중치의 변화를 주는 방법이다.

단어가 여러 문장에서 많이 나온다고 꼭 중요한 단어일까? 
꼭 그렇지 않다. I, It, this, that 등의 대명사 또는 지시대명사, 관사나 접속사 등은 관심있는 유의미한 단어가 아님에도 어느 문장에나 나온다. 

이러한 점을 반영해 여러 문장에 동시에 나오면 페널티를 주고, 나오는 총 문장 수 자체가 적은 단어에 가중치를 더 주는 방법이 TF-IDF라고 할 수 있다.
TF: 문서가 주어졌을 때 이 단어가 출현한 빈도
IDF: $log(\frac{총문장수}{해당 단어 출연 문장 개수 +1})$


||I|am|a|student|smart|
|:-:|:-:|:-:|:-:|:-:|:-:|
I am a student|1|1|1|1|0|
I am smart|1|1|0|0|1|
TOTAL|2|2|1|1|1|
$\frac{총문장수}{해당 단어 출연 문장 개수 +1}$|$\frac {2}{2}$|$\frac {2}{2}$|$\frac {2}{1}$|$\frac {2}{1}$|$\frac {2}{1}$
TF|$\frac {2}{7}$|$\frac {2}{7}$|$\frac {1}{7}$|$\frac {1}{7}$|$\frac {1}{7}$
IDF(log)|0|0|0.3|0.3|0.3

#### 유사도(similarity)
주로 cosine 유사도를 사용하며, 두 벡터간의 유사도를 측정하는 방법이다. 자연어 처리에서는 두 단어 간의 유사를 측정할 필요가 있는데, 통계기반의 모델에서는 모든 벡터들이 서로 직각을 이뤄 유사도가 0을 향한다. happy와 unhappy는 정반대의 뜻을 하고 있지만, 유사도는 전혀 알 수없는 단점을 갖고 있다.

<br>
<br>

### 2. 신경망 언어 모델(Network Language Model)
신경망 언어 모델 중 **분포 기반의 단어 표현(Distributed Representation)** 을 알아본다.
기존 빈도 기반의 표현 방법들의 단점은 단어의 의미나 문맥을 고려하지 않았지만, 분포 기반의 단어 표현방식은 분포 가설에 입각해 의미가 비슷한 단어들을 유추해낼 수 있다.

**분포가설:** 비슷한 위치의 단어는 비슷한 의미를 띄운다는 가설. 

**Embedding Word:** 
단어를 고정길이의 벡터로 표현하여 비교적 연속적인 수로 나타내어 매핑을 해두고, 필요시 이를 단어와 매칭하는 데에 사용하여 비슷한 의미를 지닌 단어들에 대한 벡터들이 서로 가까이 존재하며 유사도를 부여하는 방법이다. 

아래 분포 기반의 벡터화 방법들은 모두 임베딩 과정을 통해 단어 간 연관성, 유사도를 파악할 수 있도록 한 것이다.


#### word2vec:
가장 기본이 되는 분포 기반 단어 표현으로써 임베딩을 통해 기존의 토큰이 이뤄져 있던 원핫벡터보다 저차원으로 나타낼 수 있다. 
임베딩된 벡터를 통해 단어를 시각화해보면 확실히 의미적, 문법적 관계를 볼 수 있다. gensim 패키지를 이용해 작업할 수 있다.
- CBOW(Continuous Bag Of Words): 주변 단어를 바탕으로 중심단어를 예측하는 방식

- Skip-gram: 중심단어를 바탕으로 주변 단어를 예측하는 방식. 기본적으로 주변을 예측하다보니 학습량이 더 많아지고 성능 자체가 CBOW보다 더 좋다.

<br>
<br>

- OOV(Out Of Voca) error: 단점이라면, 말뭉치(corpus)에 없는 단어를 임베딩 할 경우, 에러가 발생한다.

word2vec의 구조:
1. 입력층: 원핫벡터의 차원 = 토큰의 수
2. 은닉층: 임베딩 벡터의 차원수 만큼 설정(직접 설정필요)
3. 출력층: 단어의 수 만큼이 출력되므로 입력층와 같아진다.



#### FastText:
word2vec의 방식에 더해, 단어(word)가 아닌 철자(character)기반의 임베딩 방식을 통해 OOV 문제를 해결한다. 철자기반 임베딩은 단어를 뜯어보면서 단어의 구조를 바탕으로 유추하는 메커니즘이다.

* character n_gram: 철자를 n개로 묶어서 단어를 유추하도록 하는 방식이다.
접두사, 접미사의 표시로써 <>꺽새를 넣어준다.
ex) taking, 3-6 grams의 경우 아래와 같이 표기되어 학습이 이뤄진다. 
3	<ta, tak, aki, kin, ing, ng>
4	<tak, taki, akin, king, ing>
5	<taki, takin, aking, king>
6	<takin, taking, aking>




## 자연어 전처리(PreProcessing)

자연어 역시도 전처리를 진행해야 모델을 돌릴 수 있고, 보다 유의미한 모델의 활용이 될 수 있다. 전처리는 이전까지 해왔던 특성공학이나 EDA와는 약간 다르다. 필요한 단어만을 캐치할 수 있도록 데이터를 정제하는 것이다. 그것을 위한 방법들을 아래와 같이 정리해본다.

### 내장 Methods와 정규식을 이용한 차원의 저주 문제 해결
replace와 split, strip 등의 내장 메서드를 이용해 변경 및 삭제가 필요한 단어들을 미리 나누거나 없애고, 합칠 수 있는 단어는 최대한 합쳐서 해당 row(doc)의 문장(토큰의 모음)을 간소화 하는 것이 가장 먼저 진행 되어야 한다.  

토큰의 수가 곧 입력층 features 수가 되기 때문에 차원의 저주(Curse of Dimension)으로 인한 성능 저하를 막기 위해선 대소문자가 다름으로 인해 단어가 늘어나는 등 쓸데없는 차원증가를 없애야 한다.

### 불용어 처리
I, and과 같은 대명사나 접속사 등 분석하는데에 전혀 필요없는데 모든 문서, 문장에 나와 빈도 상 상위에 나오는 단어를 불용어라고 한다. 
Spacy 라이브러리를 이용하면 .is_stop으로 이용할 수 있으며, nlp.Default.stop_word.union(['불용어리스트']와 같은 구조로 필요시 불용어 사전에 추가를 해줌으로써 사용가능하다.

### 어간추출(Stemming)과 표제어추출(lemmatization)
#### 어간추출(stemming/nltk):
단어의 의미가 포함된 부분을 파악해 그 이외의 부분을 제거한다. ex) learning, learnd > learn
nltk의 PorterStemmer를 사용해서 어간추출을 진행할 수 있다. 
ed, s, ing 등 미리 정해져 있는 로직으로 단어를 정리하는 것이기 때문에 정교하지 못하지만, 속도가 빨라 빠르게 대략적인 키워드 분석이 필요할 때 사용한다.

#### 표제어추출(lemmatization/lemma_)
위 어간추출과 달리 정확한 단어를 사전형으로 표현하는 방법이다. 정교한 방법이긴 하나, 그만큼 로직 내부적으로 많은 연산을 필요로 하기 때문에 시간이 오래걸린다.
표제어추출의 경우 keras에서 지원하고있어 token.lemma_를 통해 사용할 수 있다.

### 통계적 트리밍(trimming)
빈도가 극도로 낮은 경우는 정말 해당 문서에서만 잠깐 언급하는 단어일 수 있다는 점에 초점을 둔 방법으로, 단어(토큰)의 분포를 나타냈을 때, 전체 분포 중 몇%(예: 0.01%) 아래까지는 분석에 사용하지 않도록 삭제하는 방법이다.

### DTM (Document-Term Matrix)
이름 그대로 문서-단어 행렬을 의미한다. 토큰화한 단어를 onehot vector로 만들어준 문서(doc)는 행으로, 단어(term)는 열로 두어 각 단어가 문서 내에서 몇개가 들어가는지 직관적으로 볼 수 있다.

<br>

<br>

### 자연어 처리의 활용:
Text data에 대한 의미와 구조를 파악하여, 이를 활용해 다양한 분야에서 사용한다.

#### 분류(classificaiton): 
text를 바탕으로 뉴스 기사를 분류하거나, 필요한 키워드를 분류한다. 커머스나 서비스 분야에서 감성 연관어를 파악해 고객의 경험을 파악하기도 한다.

#### 자연어 추론(Inference): 
자연어를 분석해서 해당 문장을 토해로 어떠한 전제를 가지고, 그에 대한 가설이 True or False인지를 파악할 수 있다. 
ex) a는 외출을 했다. h: a는 옷을 입고있다. 

#### 기계 독해 (Machine Reading Comprehension)
